#include "inv_aes.h"

/*     
       A generic SmartCard firmware allowing for communication based 
       on ISO 7816 Part 3/Part 4 protocol standards, incorporating 
       safe AES-128 with masking and shuffling for decryption purposes.

       Authors:: Ermin Sakic, Thomas Wohlfahrt
 
       Licensed to the Apache Software Foundation (ASF) under one
       or more contributor license agreements.  See the NOTICE file
       distributed with this work for additional information
       regarding copyright ownership.  The ASF licenses this file
       to you under the Apache License, Version 2.0 (the
       "License"); you may not use this file except in compliance
       with the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing,
       software distributed under the License is distributed on an
       "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       KIND, either express or implied.  See the License for the
       specific language governing permissions and limitations
       under the License.
*/


/*
Hier soll masking angewendet werden:

Problem: Zufallszahl (howto init)


Einmal pro Entschlüsselung:
	1) pick random:		m1, m2, m3, m4, m, m'
	2) compute:			m1',m2',m3',m4'

	=>	Mask[10]
	=>	InvSbox_masked[255]
	=>	RoundKey_masked[11][16]


	(Atmega644 hat 64KB => genug)
	
*/


// KONSTANT ARRAYS:

/** Alle 10 Rundenschlüssel:
	Werden in plaintext auf dem controller abgespeichert.
	Die Rundenschlüssel wurden schon zuvor berechnet, 
	und müssen nich mehr on-the-fly berechnet werden
*/
const uint8_t roundKey[11][16] = {
{0x55,0xc1,0x79,0x04,0xc3,0xdc,0x04,0x52,0x2a,0x0c,0x76,0xef,0xe8,0xca,0x48,0xb5},
{0x20,0x93,0xac,0x9f,0xe3,0x4f,0xa8,0xcd,0xc9,0x43,0xde,0x22,0x21,0x89,0x96,0x97},
{0x85,0x03,0x24,0x62,0x66,0x4c,0x8c,0xaf,0xaf,0x0f,0x52,0x8d,0x8e,0x86,0xc4,0x1a},
{0xc5,0x1f,0x86,0x7b,0xa3,0x53,0x0a,0xd4,0x0c,0x5c,0x58,0x59,0x82,0xda,0x9c,0x43},
{0x9a,0xc1,0x9c,0x68,0x39,0x92,0x96,0xbc,0x35,0xce,0xce,0xe5,0xb7,0x14,0x52,0xa6},
{0x70,0xc1,0xb8,0xc1,0x49,0x53,0x2e,0x7d,0x7c,0x9d,0xe0,0x98,0xcb,0x89,0xb2,0x3e},
{0xf7,0xf6,0x0a,0xde,0xbe,0xa5,0x24,0xa3,0xc2,0x38,0xc4,0x3b,0x09,0xb1,0x76,0x05},
{0x7f,0xce,0x61,0xdf,0xc1,0x6b,0x45,0x7c,0x03,0x53,0x81,0x47,0x0a,0xe2,0xf7,0x42},
{0x67,0xa6,0x4d,0xb8,0xa6,0xcd,0x08,0xc4,0xa5,0x9e,0x89,0x83,0xaf,0x7c,0x7e,0xc1},
{0x6c,0x55,0x35,0xc1,0xca,0x98,0x3d,0x05,0x6f,0x06,0xb4,0x86,0xc0,0x7a,0xca,0x47},
{0x80,0x21,0x95,0x7b,0x4a,0xb9,0xa8,0x7e,0x25,0xbf,0x1c,0xf8,0xe5,0xc5,0xd6,0xbf}
};
const uint8_t inv_sbox[256] = {
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
	0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
	0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
	0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
	0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
	0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
	0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
	0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
	0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
	0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
	0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
	0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
	0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
	0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
	0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
	0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
	0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

/**	Lookup tables für die GF Feld Multiplikation => spart Zeit - */
const uint8_t mul_09[256]={
	0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
	0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
	0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
	0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
	0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
	0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
	0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
	0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
	0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
	0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
	0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
	0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
	0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
	0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
	0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
	0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
};
const uint8_t mul_11[256]={
	0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
	0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
	0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
	0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
	0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
	0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
	0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
	0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
	0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
	0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
	0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
	0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
	0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
	0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
	0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
	0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
};
const uint8_t mul_13[256]={
	0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
	0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
	0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
	0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
	0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
	0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
	0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
	0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
	0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
	0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
	0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
	0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
	0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
	0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
	0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
	0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
};
const uint8_t mul_14[256]={
	0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
	0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
	0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
	0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
	0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
	0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
	0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
	0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
	0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
	0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
	0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
	0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
	0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
	0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
	0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
	0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
};

//GLOBALS:-) because it's more easy
/** InvSbox muss für jede neue Maske berechnet werden */
uint8_t InvSbox_masked[256];
/** Insgesammt 10 Masken Parameter */
uint8_t Mask[10];
/** Alle Rundenschlüssel richtig Maskiert */
uint8_t RoundKey_masked[11][16];

//Implementation:

//MASKED AES OPERATIONS:
void inv_mixColumns(uint8_t state[16]){

/* Inverse Mix Columns:
 * [w]      [14  11  13   9]    [a]
 * [x]  =   [ 9  14  11  13]  * [b]
 * [y]      [13   9  14  11]    [c]
 * [z]      [11  13   9  14]    [d]
 *
 *  w =   14*a  + 11*b + 13*c +  9*d
 *  x =    9*a  + 14*b + 11*c + 13*d
 *  y =   13*a  +  9*b + 14*c + 11*d
 *  z =   11*a  + 13*b +  9*c + 14*d
 */

    uint8_t temp[4];
    for(uint8_t i = 0; i < 16; i+=4){
        temp[0] = state[i];
        temp[1] = state[i+1];
        temp[2] = state[i+2];
        temp[3] = state[i+3];

        state[i]	=	mul_14[temp[0]]	^ mul_11[temp[1]]   ^mul_13[temp[2]]	^mul_09[temp[3]];
        state[i+1]	=	mul_09[temp[0]]	^ mul_14[temp[1]]	^mul_11[temp[2]]	^mul_13[temp[3]];
        state[i+2]	=	mul_13[temp[0]]	^ mul_09[temp[1]]	^mul_14[temp[2]]	^mul_11[temp[3]];
        state[i+3]	=	mul_11[temp[0]]	^ mul_13[temp[1]]	^mul_09[temp[2]]	^mul_14[temp[3]];
    }
}
void inv_shiftRows(uint8_t state[16]){
	
	//
	// [s00|s04|s08|s12] =>   [s00|s04|s08|s12] 
	// [s01|s05|s09|s13] =>   [s13|s01|s05|s09] 
	// [s02|s06|s10|s14] =>   [s10|s14|s02|s06] 
	// [s03|s07|s11|s15] =>   [s07|s11|s15|s03] 
	// 

    uint8_t temp;
    //Row 1: unchanged
    //Row 2: one to right
    temp = state[1];
    state[1] = state[13];
    state[13] = state[9];
    state[9] = state[5];
    state[5] = temp;
    //Row 3: two to right
    temp = state[10];
    state[10] = state[2];
    state[2] = temp;
    temp = state[14];
    state[14] = state[6];
    state[6] = temp;
    //Row 4: tree to right
    temp = state[3];
    state[3] = state[7];
    state[7] = state[11];
    state[11] = state[15];
    state[15] = temp;

}
void addRoundKey_masked(uint8_t state[16],uint8_t round){

	//same as add_roundkey but only with precalculated Roundkeys with the right Masks:
	
	for(uint8_t i=0;i<16;i++){
		state[i] ^= RoundKey_masked[round][i];
	}
}
void inv_subBytes_masked(uint8_t state[16]){
	
	//like Sbox[s] only with included Masks
	for (uint8_t i = 0; i < 16; i++) {
		state[i] = InvSbox_masked[state[i]];
	}
}
void remask(uint8_t s[16], uint8_t m1, uint8_t m2, uint8_t m3, uint8_t m4, uint8_t m5, uint8_t m6, uint8_t m7, uint8_t m8){
	
	//Mask the input Array[16] with:
	//	[....]				[m1^m5|m1^m5|m1^m5|m1^m5]
	//	[....]	EXOR		[m2^m6|m2^m6|m2^m6|m2^m6]
	//	[....]				[m3^m7|m3^m7|m3^m7|m3^m7]
	//	[....]				[m4^m8|m4^m8|m5^m8|m4^m8]
	
	
	for(int i = 0; i< 4; i++){
		s[0+i*4]	= s[0+i*4] ^ (m1^m5);
		s[1+i*4]	= s[1+i*4] ^ (m2^m6);
		s[2+i*4]	= s[2+i*4] ^ (m3^m7);
		s[3+i*4]	= s[3+i*4] ^ (m4^m8);
	}
}


//PRECALCULATIONS:
void calcMixColMask(){
	
	//calculate [m1',m2',m3',m4'] <= Mixcolum([m1,m2,m3,m4])
	//Mask[0] = m1
	//Mask[1] = m2
	//Mask[2] = m3
	//Mask[3] = m4
	//Mask[4] = m
	//Mask[5] = m'
	//Mask[6] = m1' = m5
	//Mask[7] = m2' = m6
	//Mask[8] = m3' = m7
	//Mask[9] = m4' = m8
		
	Mask[6]	=	mul_14[Mask[0]]	^ mul_11[Mask[1]]   ^mul_13[Mask[2]]	^mul_09[Mask[3]];
	Mask[7]	=	mul_09[Mask[0]]	^ mul_14[Mask[1]]	^mul_11[Mask[2]]	^mul_13[Mask[3]];
	Mask[8]	=	mul_13[Mask[0]]	^ mul_09[Mask[1]]	^mul_14[Mask[2]]	^mul_11[Mask[3]];
	Mask[9]	=	mul_11[Mask[0]]	^ mul_13[Mask[1]]	^mul_09[Mask[2]]	^mul_14[Mask[3]];
	
}
void calcInvSbox_masked(){

	//precalculate the needed Sbpx to change from Mask m to Maks m'
	for(int cnt=0;cnt<256;cnt++){
		InvSbox_masked[cnt^Mask[4]] = inv_sbox[cnt]^Mask[5];
	}	
}
void init_masked_round_keys(){
	//Mask[0] = m1
	//Mask[1] = m2
	//Mask[2] = m3
	//Mask[3] = m4
	//Mask[4] = m
	//Mask[5] = m'
	//Mask[6] = m1' = m5
	//Mask[7] = m2' = m6
	//Mask[8] = m3' = m7
	//Mask[9] = m4' = m8
	
	//	10th RK Mask m1'-m4' to Mask m
	remask(RoundKey_masked[10],Mask[6],Mask[7],Mask[8],Mask[9],Mask[4],Mask[4],Mask[4],Mask[4]);

	//	2nd-9th RK Mask m' to Mask m1-m4
	for(int i = 1; i<10;i++){
		remask(RoundKey_masked[i],Mask[0],Mask[1],Mask[2],Mask[3],Mask[5],Mask[5],Mask[5],Mask[5]); 
	}
	
	//1st RK Mask m' to 0
	remask(RoundKey_masked[0],0,0,0,0,Mask[5],Mask[5],Mask[5],Mask[5]); 
}
void copy_key(){
	//Kopy the right roundkeys to masked Key Array
	
	for(uint8_t i=0;i<11;i++){
		for(uint8_t j=0;j<16;j++){
			RoundKey_masked[i][j] = roundKey[i][j];
		}
	}
}
void init_masking(){
	//Mask[0] = m1
	//Mask[1] = m2
	//Mask[2] = m3
	//Mask[3] = m4
	//Mask[4] = m
	//Mask[5] = m'
	//Mask[6] = m1' = m5
	//Mask[7] = m2' = m6
	//Mask[8] = m3' = m7
	//Mask[9] = m4' = m8
	
	copy_key();
	
	//just for fun (hiding, shadowing maskin:-)
	for(int i = 0; i< 287; i++){
		rand(); 
	}
	
	//Define Mask: m1,m2,m3,m4,m,m'
	for(uint8_t i=0;i<6;i++){
		Mask[i] = rand() % 0xFF;
	}
	//Calculates: m1',m2',m3',m4'
	calcMixColMask();
	//Calculate the Masked Sbox lookup (uint_8t[256])
	calcInvSbox_masked();  // m -> m'
	
	init_masked_round_keys();
	
}


void gen_random_sequence(uint8_t hiding_sequence[16]){
	
	
	int flag = 0;
	
	uint8_t indi[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
		
	int val;	
	for (int i = 15; i >= 0 ;i--){
		val = rand() % (i+1);
		
		hiding_sequence[i] = indi[val]; 
		
		//shift all remaining values:
		//eg:
		// val = 12 =>
		// indi[] new = {0,1,2,3,4,5,6,7,8,9,10,11, 13,14,15,  15}

		for( int j = val; j < i ; j++){
			indi[j] = indi[j+1];			
		}
	}	
	
}

void inv_subBytes_masked_rand(uint8_t state[16],uint8_t hiding_sequence[16]){
		//like Sbox[s] only with included Masks
		//shuffled
		for (uint8_t i = 0; i < 16; i++) {
			state[hiding_sequence[i]] = InvSbox_masked[state[hiding_sequence[i]]];
		}
}

//!!!MAIN FUNKTION!!!//
void inv_aes128(uint8_t state[16])
{	
	
	//Damn English - German Mix...
	//Firste define all Masks[1-10] 
	//then precalculate Sbox_masked and also the correct roundKeys
	
	//Try generating random sequence for Subbytes:
	uint8_t hiding_sequence[16];
	gen_random_sequence(hiding_sequence);
	
	init_masking();
	
	
	// 1.: Maskiert State mit m1'-m4'
	remask(state,Mask[6],Mask[7],Mask[8],Mask[9],0,0,0,0);
	
	//2.: Rundenschlüssel 11 (beinhalltet schon m1'-m4' und m
	// Maske m1'-m4' => m
    addRoundKey_masked(state, 10);  
	
	//3.: Maskierte Subbyte Operation
	// Maske M => m'
	//inv_subBytes_masked(state); // m => m'
	//inv_subBytes_masked_rand(state,hiding_sequence);
	//4.: Shiftrows
	// Maske m' => m' (bleibt natürlich gleich)
	//inv_shiftRows(state); // m' bleibt m'
	
	if(rand()%2 == 1){
		inv_subBytes_masked_rand(state,hiding_sequence);
		inv_shiftRows(state);
	}
	else{
		inv_shiftRows(state);
		inv_subBytes_masked_rand(state,hiding_sequence);
	}
	
	
	
	//Loop für Rundenschlüssel 10->2
    for (uint8_t i = 9; i > 0; i--) {
		
		//5.	Maske m' => m1-m4 
        addRoundKey_masked(state, i);	
		
		//6.	Maske m1-m4 -> m1'-m4'
		inv_mixColumns(state);			
		
		//7.	Maske m1'-m4' -> m
		remask(state,Mask[6],Mask[7],Mask[8],Mask[9],Mask[4],Mask[4],Mask[4],Mask[4]); 
		
		/*with Shuffling:*/
		//8.	Maske m => m'
		//inv_subBytes_masked(state);
		//9.	Maske m' bleibt m'
		//inv_shiftRows(state);
		//gen_random_sequence(hiding_sequence);
		if(rand()%2 == 1){
			inv_subBytes_masked_rand(state,hiding_sequence);
			inv_shiftRows(state);
		}
		else{
			inv_shiftRows(state);
			inv_subBytes_masked_rand(state,hiding_sequence);
		}
		/**/
		
    }
	
	//10. Addiert Rundenschlüssel 1:
	//Maske m' => 0
    addRoundKey_masked(state, 0);

	//Fertig:-)
}
